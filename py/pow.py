"""이 파일에서는 다음의 내용을 다룬다.

1. pow와 분할 정복을 이용한 거듭제곱
2. pow와 모듈로 곱셈 역원
"""

# python에서는 거듭제곱을 계산하는 방법을 몇 가지 제공한다.
print(2**10)  # 1024
print(pow(2,10))  # 1024

# 얼핏 보면 pow함수가 더 길어서 숏코딩에 불리할것 같다. 그런데 이 내장함수에
# 세 번째 인자가 들어갈 수 있다는 것을 알고 있었는가?

# https://docs.python.org/3/library/functions.html#pow
# `pow(base, exp, mod=None)`

# 세 번짜 인자를 넣으면 모듈로 연산을 지원한다! 
# 이를 통해서 원래는 직접 구현해서 사용했어야 하는 기법 두 개를 내장함수로
# 뭉개고 넘어갈 수 있다.


# 1. pow와 분할 정복을 이용한 거듭제곱

# pow(base, exp, mod)의 계산 결과는 `pow(base, exp) % mod`와 동일하지만,
# 이 내장함수는 base를 exp번 곱하고 나서 mod로 나누는 것보다 더 효율적으로
# 동작한다. 자세한 내용은 `분할 정복을 이용한 거듭제곱`을 검색해보면 좋다.

# 이 기법을 활용한 문제는 solved에서 같은 이름으로 태그가 달려있다.
# [solved.ac - 문제 › 태그 › exponentiation_by_squaring](https://solved.ac/problems/tags/exponentiation_by_squaring)

# 원래라면 글 작성 시점 기준 solved에서 실버 1 난이도로 분류된 아래 문제를
# 풀기 위해서는 위의 기법을 직접 구사해야 했겠지만, python에서는 내장함수로
# 바로 풀린다.
# [곱셈](https://www.acmicpc.net/problem/1629)
print(pow(*map(int,input().split())))


# 2. pow와 모듈로 곱셈 역원

# 원래라면 pow(38, -1)은 1/38로 계산해야 한다. 하지만 정수론에서는 주어진
# 정수 x, m에 대해 다음의 식을 만족하는 y를 x의 모듈로 역원이라고 한다.
# `(x * y) % m == 1`
# 이에 따르면 pow(38, -1, 97)은 23이 된다.

# 그러니까, 원래라면 38 * (1/38)을 계산하면 1이 되니까 pow(38, -1)이 1/38이
# 되는 건데, 위와 같이 97로 모듈로 연산이 걸려있는 상황에서는 (23 * 38) % 97
# 을 계산한 값도 1이 되므로 23이 모듈로 97에서 38에 대한 역원이 되는 것이다.

# 이는 큰 이항계수에 모듈로가 걸린 값을 계산해야 하는 상황에서 매우 유용하게
# 활용할 수 있다. nCk를 1000000007로 나눈 값을 계산하는 다음의 문제는 아래의
# 코드로 풀 수 있다.
# [이항 계수 3](https://www.acmicpc.net/problem/11401)
a,b=map(int,input().split())
c,m=1,1000000007
for i in range(b):c*=pow(i+1,-1,m)*(a-i);c%=m
print(c)
